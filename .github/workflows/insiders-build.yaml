name: insiders-build
on:
    workflow_dispatch:
    push:
        branches:
            - master
jobs:
    insiders-build:
        strategy:
            matrix:
                os: [win-code-sign, mac-build1, mac-build2, ubuntu-latest]
                include:
                    - os: win-code-sign
                      build: |
                          # Inject git SHA and date into package.json
                          $GIT_SHA = (git rev-parse --short HEAD)
                          $BUILD_DATE = (Get-Date -Format "yyyyMMdd")
                          (Get-Content package.json) -replace '"version": "(.*)"', ('"version": "$1-' + $BUILD_DATE + '-' + $GIT_SHA + '"') | Set-Content package.json

                          # Create a single JS file using esbuild
                          ./node_modules/.bin/esbuild ./src/butler.js --bundle --outfile=./build/build.cjs --format=cjs --platform=node --target=node23 --inject:./src/lib/import-meta-url.js --define:import.meta.url=import_meta_url

                          # Generate blob to be injected into the binary
                          node --experimental-sea-config build-script/sea-config.json

                          # Get a copy of the Node executable
                          node -e "require('fs').copyFileSync(process.execPath, '${env:DIST_FILE_NAME}.exe')" 

                          pwd
                          dir

                          # -------------------
                          # Remove the signature from the executable
                          $processOptions1 = @{
                            FilePath = "C:\Program Files (x86)/Windows Kits/10/bin/10.0.22621.0/x64/signtool.exe"
                            Wait = $true
                            ArgumentList = "remove", "/s", "./${env:DIST_FILE_NAME}.exe"
                            WorkingDirectory = "."
                            NoNewWindow = $true
                          }
                          Start-Process @processOptions1

                          npx postject "${env:DIST_FILE_NAME}.exe" NODE_SEA_BLOB build/sea-prep.blob --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2
                            
                          # -------------------
                          # Sign the executable
                          # 1st signing
                          $processOptions1 = @{
                            FilePath = "C:\Program Files (x86)/Windows Kits/10/bin/10.0.22621.0/x64/signtool.exe"
                            Wait = $true
                            ArgumentList = "sign", "/sha1", "$env:CODESIGN_WIN_THUMBPRINT", "/tr", "http://time.certum.pl", "/td", "sha256", "/fd", "sha1", "/v", "./${env:DIST_FILE_NAME}.exe"
                            WorkingDirectory = "."
                            NoNewWindow = $true
                          }
                          Start-Process @processOptions1

                          # -------------------
                          # 2nd signing
                          $processOptions2 = @{
                            FilePath = "C:\Program Files (x86)/Windows Kits/10/bin/10.0.22621.0/x64/signtool.exe"
                            Wait = $true
                            ArgumentList = "sign", "/sha1", "$env:CODESIGN_WIN_THUMBPRINT", "/tr", "http://time.certum.pl", "/td", "sha256", "/fd", "sha256", "/v", "./${env:DIST_FILE_NAME}.exe"
                            WorkingDirectory = "."
                            NoNewWindow = $true
                          }
                          Start-Process @processOptions2

                          # -------------------
                          # Create insider's build zip
                          $compress = @{
                            Path = "./${env:DIST_FILE_NAME}.exe"
                            CompressionLevel = "Fastest"
                            DestinationPath = "${env:DIST_FILE_NAME}--win-x64--${{ github.sha }}.zip"
                          }
                          Compress-Archive @compress

                          # -------------------
                          # Add following directories & files to the created zip file, in the ./config directory.
                          # - ./src/config/log_appender_xml
                          # - ./src/config/email_templates
                          # - ./src/config/slack_templates
                          # - ./src/config/teams_templates
                          # - ./src/config/production_template.yaml
                          # - ./src/config/schedule_template.yaml
                          mkdir config
                          Copy-Item -Path ./src/config/log_appender_xml/ -Destination ./config/ -Recurse
                          Copy-Item -Path ./src/config/email_templates/ -Destination ./config/ -Recurse
                          Copy-Item -Path ./src/config/slack_templates/ -Destination ./config/ -Recurse
                          Copy-Item -Path ./src/config/teams_templates/ -Destination ./config/ -Recurse
                          Copy-Item -Path ./src/config/production_template.yaml -Destination ./config/
                          Copy-Item -Path ./src/config/schedule_template.yaml -Destination ./config/

                          Compress-Archive -Path "./config" -Update -DestinationPath "./${env:DIST_FILE_NAME}--win-x64--${{ github.sha }}.zip"

                          # -------------------
                          # Clean up
                          Remove-Item -Force build/build.cjs

                          # dir
                      # artifact_release_name: release-binaries-win
                      # artifact_release_path: release-binaries-win/*
                      artifact_insider: butler--win-x64--${{ github.sha }}.zip

                    # x64 build
                    - os: mac-build1
                      build: |
                          # Inject git SHA and date into package.json
                          GIT_SHA=$(git rev-parse --short HEAD)
                          BUILD_DATE=$(date +%Y%m%d)
                          VERSION=$(grep -o '"version": "[^"]*"' package.json | cut -d'"' -f4)
                          sed -i '' "s/\"version\": \".*\"/\"version\": \"$VERSION-$BUILD_DATE-$GIT_SHA\"/" package.json

                          # Create a single JS file using esbuild
                          ./node_modules/.bin/esbuild ./src/butler.js --bundle --outfile=./build/build.cjs --format=cjs --platform=node --target=node23 --inject:./src/lib/import-meta-url.js --define:import.meta.url=import_meta_url

                          # Generate blob to be injected into the binary
                          node --experimental-sea-config build-script/sea-config.json

                          # Get a copy of the Node executable
                          cp $(command -v node) ${DIST_FILE_NAME}

                          # Remove the signature from the Node executable
                          codesign --remove-signature ${DIST_FILE_NAME}

                          # Inject the blob
                          npx postject ${DIST_FILE_NAME} NODE_SEA_BLOB build/sea-prep.blob --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2 --macho-segment-name NODE_SEA

                          security delete-keychain build.keychain || true

                          pwd
                          ls -la

                          # Start signing of the binary

                          # -------------------
                          # We need to create a new keychain, otherwise using the certificate will prompt
                          # with a UI dialog asking for the certificate password, which we can't
                          # use in a headless CI environment

                          # Turn our base64-encoded certificate back to a regular .p12 file
                          echo $MACOS_CERTIFICATE | base64 --decode > certificate.p12

                          echo "DEBUG: Setting KEYCHAIN_NAME environment variable"
                          export KEYCHAIN_NAME="build.keychain"

                          echo "DEBUG: Creating new keychain"
                          security create-keychain -p "$MACOS_CI_KEYCHAIN_PWD" "${KEYCHAIN_NAME}"

                          echo "DEBUG: Getting current keychain list"
                          OLD_KEYCHAIN_NAMES=$(security list-keychains -d user | sed -e 's/"//g' | xargs)
                          echo "DEBUG: Current keychains: ${OLD_KEYCHAIN_NAMES}"

                          echo "DEBUG: Setting keychain search list"
                          security list-keychains -d user -s "${KEYCHAIN_NAME}" ${OLD_KEYCHAIN_NAMES}

                          echo "DEBUG: Getting current default keychain"
                          DEFAULT_KEYCHAIN=$(security default-keychain -d user | sed -e 's/"//g' | xargs)
                          echo "DEBUG: Default keychain is: ${DEFAULT_KEYCHAIN}"

                          echo "DEBUG: Setting our keychain as default"
                          security default-keychain -d user -s "${KEYCHAIN_NAME}"

                          echo "DEBUG: Unlocking keychain"
                          security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" "${KEYCHAIN_NAME}"

                          echo "DEBUG: Importing certificate into keychain"
                          security import certificate.p12 -k "${KEYCHAIN_NAME}" -P "$MACOS_CERTIFICATE_PWD" -T /usr/bin/codesign

                          echo "DEBUG: Setting keychain timeout to prevent locking"
                          security set-keychain-settings -t 3600 -l "${KEYCHAIN_NAME}"

                          echo "DEBUG: Setting key partition list"
                          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$MACOS_CI_KEYCHAIN_PWD" "${KEYCHAIN_NAME}"

                          echo "DEBUG: Performing codesign operation"
                          codesign --force -s "$MACOS_CERTIFICATE_NAME" -v "./${DIST_FILE_NAME}" --deep --strict --options=runtime --timestamp --entitlements ./release-config/${DIST_FILE_NAME}.entitlements

                          echo "DEBUG: Verifying code signature"
                          codesign -vvv --deep --strict "./${DIST_FILE_NAME}"

                          # -------------------
                          # Notarize
                          # Store the notarization credentials so that we can prevent a UI password dialog from blocking the CI
                          echo "Create keychain profile"
                          # Get the absolute path to the keychain in ~/Library/Keychains/ with the -db suffix macOS adds to keychain files
                          KEYCHAIN_PATH=~/Library/Keychains/${KEYCHAIN_NAME}-db
                          echo "DEBUG: Using keychain at path: ${KEYCHAIN_PATH}"
                          xcrun notarytool store-credentials "notarytool-profile" --apple-id "$PROD_MACOS_NOTARIZATION_APPLE_ID" --team-id "$PROD_MACOS_NOTARIZATION_TEAM_ID" --password "$PROD_MACOS_NOTARIZATION_PWD" --keychain "${KEYCHAIN_PATH}"

                          # -------------------
                          # We can't notarize an app bundle directly, but we need to compress it as an archive.
                          # Therefore, we create a zip file containing our app bundle, so that we can send it to the
                          # notarization service
                          # Notarize insider binary
                          echo "Creating temp notarization archive for insider build"
                          zip -r "./${DIST_FILE_NAME}--macos-x64--${{ github.sha }}.zip" "./${DIST_FILE_NAME}" -x "*.DS_Store"

                          # Include following directories & files in the created zip file, in the ./config directory.
                          # - ./src/config/log_appender_xml
                          # - ./src/config/email_templates
                          # - ./src/config/slack_templates
                          # - ./src/config/teams_templates
                          # - ./src/config/production_template.yaml
                          # - ./src/config/schedule_template.yaml
                          cd src
                          zip -u -r "../${DIST_FILE_NAME}--macos-x64--${{ github.sha }}.zip" "./config/email_templates" "./config/slack_templates" "./config/teams_templates" "./config/production_template.yaml" "./config/schedule_template.yaml" "./config/log_appender_xml" -x "*.DS_Store"
                          cd ..


                          # Here we send the notarization request to the Apple's Notarization service, waiting for the result.
                          echo "Notarize insider app"
                          xcrun notarytool submit "./${DIST_FILE_NAME}--macos-x64--${{ github.sha }}.zip" --keychain-profile "notarytool-profile" --wait --keychain "${KEYCHAIN_PATH}"

                          echo "DEBUG: Restoring original default keychain"
                          security default-keychain -d user -s "$DEFAULT_KEYCHAIN" || echo "WARNING: Failed to restore default keychain, continuing anyway"

                          echo "DEBUG: Restoring original keychain list"
                          security list-keychains -d user -s ${OLD_KEYCHAIN_NAMES} || echo "WARNING: Failed to restore keychain list, continuing anyway"


                          # -------------------
                          # Clean up
                          # Delete build keychain
                          security delete-keychain build.keychain
                          rm build/build.cjs build/sea-prep.blob certificate.p12

                          ls -la
                      artifact_insider: butler--macos-x64--${{ github.sha }}.zip

                    # Arm 64 build
                    - os: mac-build2
                      build: |
                          # Inject git SHA and date into package.json
                          GIT_SHA=$(git rev-parse --short HEAD)
                          BUILD_DATE=$(date +%Y%m%d)
                          VERSION=$(grep -o '"version": "[^"]*"' package.json | cut -d'"' -f4)
                          sed -i '' "s/\"version\": \".*\"/\"version\": \"$VERSION-$BUILD_DATE-$GIT_SHA\"/" package.json

                          # Create a single JS file using esbuild
                          ./node_modules/.bin/esbuild ./src/butler.js --bundle --outfile=./build/build.cjs --format=cjs --platform=node --target=node23 --inject:./src/lib/import-meta-url.js --define:import.meta.url=import_meta_url

                          # Generate blob to be injected into the binary
                          node --experimental-sea-config ./build-script/sea-config.json

                          # Get a copy of the Node executable
                          cp $(command -v node) ${DIST_FILE_NAME}

                          # Remove the signature from the Node executable
                          codesign --remove-signature ${DIST_FILE_NAME}

                          # Inject the blob
                          npx postject ${DIST_FILE_NAME} NODE_SEA_BLOB ./build/sea-prep.blob --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2 --macho-segment-name NODE_SEA

                          security delete-keychain build.keychain || true

                          pwd
                          ls -la

                          # Start signing of the binary

                          # -------------------
                          # We need to create a new keychain, otherwise using the certificate will prompt
                          # with a UI dialog asking for the certificate password, which we can't
                          # use in a headless CI environment

                          # Turn our base64-encoded certificate back to a regular .p12 file
                          echo $MACOS_CERTIFICATE | base64 --decode > certificate.p12

                          echo "DEBUG: Setting KEYCHAIN_NAME environment variable"
                          export KEYCHAIN_NAME="build.keychain"

                          echo "DEBUG: Creating new keychain"
                          security create-keychain -p "$MACOS_CI_KEYCHAIN_PWD" "${KEYCHAIN_NAME}"

                          echo "DEBUG: Getting current keychain list"
                          OLD_KEYCHAIN_NAMES=$(security list-keychains -d user | sed -e 's/"//g' | xargs)
                          echo "DEBUG: Current keychains: ${OLD_KEYCHAIN_NAMES}"

                          echo "DEBUG: Setting keychain search list"
                          security list-keychains -d user -s "${KEYCHAIN_NAME}" ${OLD_KEYCHAIN_NAMES}

                          echo "DEBUG: Getting current default keychain"
                          DEFAULT_KEYCHAIN=$(security default-keychain -d user | sed -e 's/"//g' | xargs)
                          echo "DEBUG: Default keychain is: ${DEFAULT_KEYCHAIN}"

                          echo "DEBUG: Setting our keychain as default"
                          security default-keychain -d user -s "${KEYCHAIN_NAME}"

                          echo "DEBUG: Unlocking keychain"
                          security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" "${KEYCHAIN_NAME}"

                          echo "DEBUG: Importing certificate into keychain"
                          security import certificate.p12 -k "${KEYCHAIN_NAME}" -P "$MACOS_CERTIFICATE_PWD" -T /usr/bin/codesign

                          echo "DEBUG: Setting keychain timeout to prevent locking"
                          security set-keychain-settings -t 3600 -l "${KEYCHAIN_NAME}"

                          echo "DEBUG: Setting key partition list"
                          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$MACOS_CI_KEYCHAIN_PWD" "${KEYCHAIN_NAME}"

                          echo "DEBUG: Performing codesign operation"
                          codesign --force -s "$MACOS_CERTIFICATE_NAME" -v "./${DIST_FILE_NAME}" --deep --strict --options=runtime --timestamp --entitlements ./release-config/${DIST_FILE_NAME}.entitlements

                          echo "DEBUG: Verifying code signature"
                          codesign -vvv --deep --strict "./${DIST_FILE_NAME}"

                          # -------------------
                          # Notarize
                          # Store the notarization credentials so that we can prevent a UI password dialog from blocking the CI
                          echo "Create keychain profile"
                          # Get the absolute path to the keychain in ~/Library/Keychains/ with the -db suffix macOS adds to keychain files
                          KEYCHAIN_PATH=~/Library/Keychains/${KEYCHAIN_NAME}-db
                          echo "DEBUG: Using keychain at path: ${KEYCHAIN_PATH}"
                          xcrun notarytool store-credentials "notarytool-profile" --apple-id "$PROD_MACOS_NOTARIZATION_APPLE_ID" --team-id "$PROD_MACOS_NOTARIZATION_TEAM_ID" --password "$PROD_MACOS_NOTARIZATION_PWD" --keychain "${KEYCHAIN_PATH}"

                          # -------------------

                          # We can't notarize an app bundle directly, but we need to compress it as an archive.
                          # Therefore, we create a zip file containing our app bundle, so that we can send it to the
                          # notarization service
                          # Notarize insider binary
                          echo "Creating temp notarization archive for insider build"
                          zip -r "./${DIST_FILE_NAME}--macos-arm64--${{ github.sha }}.zip" "./${DIST_FILE_NAME}" -x "*.DS_Store"

                          # Include following directories & files in the created zip file, in the ./config directory.
                          # - ./src/config/log_appender_xml
                          # - ./src/config/email_templates
                          # - ./src/config/slack_templates
                          # - ./src/config/teams_templates
                          # - ./src/config/production_template.yaml
                          # - ./src/config/schedule_template.yaml
                          cd src
                          zip -u -r "../${DIST_FILE_NAME}--macos-arm64--${{ github.sha }}.zip" "./config/email_templates" "./config/slack_templates" "./config/teams_templates" "./config/production_template.yaml" "./config/schedule_template.yaml" "./config/log_appender_xml" -x "*.DS_Store"
                          cd ..


                          # Here we send the notarization request to the Apple's Notarization service, waiting for the result.
                          echo "Notarize insider app"
                          xcrun notarytool submit "./${DIST_FILE_NAME}--macos-arm64--${{ github.sha }}.zip" --keychain-profile "notarytool-profile" --wait --keychain "${KEYCHAIN_PATH}"

                          echo "DEBUG: Restoring original default keychain"
                          security default-keychain -d user -s "$DEFAULT_KEYCHAIN" || echo "WARNING: Failed to restore default keychain, continuing anyway"

                          echo "DEBUG: Restoring original keychain list"
                          security list-keychains -d user -s ${OLD_KEYCHAIN_NAMES} || echo "WARNING: Failed to restore keychain list, continuing anyway"


                          # -------------------
                          # Clean up
                          # Delete build keychain
                          security delete-keychain build.keychain
                          rm build/build.cjs build/sea-prep.blob certificate.p12

                          ls -la
                      # artifact_release_name: release-binaries-macos
                      # artifact_release_path: release-binaries-macos/*
                      artifact_insider: butler--macos-arm64--${{ github.sha }}.zip
                    - os: ubuntu-latest
                      build: |
                          # Inject git SHA and date into package.json
                          GIT_SHA=$(git rev-parse --short HEAD)
                          BUILD_DATE=$(date +%Y%m%d)
                          VERSION=$(grep -o '"version": "[^"]*"' package.json | cut -d'"' -f4)
                          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION-$BUILD_DATE-$GIT_SHA\"/" package.json

                          ./node_modules/.bin/esbuild ./src/butler.js --bundle --outfile=./build/build.cjs --format=cjs --platform=node --target=node23 --inject:./src/lib/import-meta-url.js --define:import.meta.url=import_meta_url
                          node --experimental-sea-config build-script/sea-config.json

                          # Get a copy of the Node executable
                          cp $(command -v node) ${DIST_FILE_NAME}
                          npx postject ${DIST_FILE_NAME} NODE_SEA_BLOB build/sea-prep.blob --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2

                          chmod +x ${DIST_FILE_NAME}

                          # Compress insider's build
                          # Include following directories & files in the created archive file.
                          # - ./src/config/log_appender_xml
                          # - ./src/config/email_templates
                          # - ./src/config/slack_templates
                          # - ./src/config/teams_templates
                          # - ./src/config/production_template.yaml
                          # - ./src/config/schedule_template.yaml
                          echo "Creating temp notarization archive for insider build"
                          zip -9 -r "./${DIST_FILE_NAME}--linux-x64--${{ github.sha }}.zip" "${DIST_FILE_NAME}" 

                          cd src
                          zip -9 -u -r "../${DIST_FILE_NAME}--linux-x64--${{ github.sha }}.zip" "./config/email_templates" "./config/slack_templates" "./config/teams_templates" "./config/production_template.yaml" "./config/schedule_template.yaml" "./config/log_appender_xml"
                          cd ..

                          # Clean up
                          rm build/build.cjs build/sea-prep.blob

                          ls -la

                      # artifact_release_name: release-binaries-linux
                      # artifact_release_path: release-binaries-linux/*
                      artifact_insider: butler--linux-x64--${{ github.sha }}.zip
        runs-on: ${{ matrix.os }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v5

            - name: Setup Node.js
              uses: actions/setup-node@v5
              with:
                  node-version: 23

            - name: Install tool for creating stand-alone executables
              run: |
                  npm install --save-exact esbuild

            - name: Install dependencies
              run: |
                  pwd 
                  npm ci

            - name: Run unit tests
              run: npm run test

            - name: Run Snyk to check for vulnerabilities
              # Snyk can be used to break the build when it detects security issues.
              # In this case we want to upload the SAST issues to GitHub Code Scanning
              #uses: snyk/actions/setup@806182742461562b67788a64410098c9d9b96adb
              if: |
                  github.repository_owner == 'ptarmiganlabs' &&
                  matrix.os == 'ubuntu-latest'
              continue-on-error: true
              uses: snyk/actions/node@master
              env:
                  # This is where you will need to introduce the Snyk API token created with your Snyk account
                  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
              with:
                  args: --file=./package.json --sarif-file-output=snyk.sarif
                  # command: test

            - name: Upload Snyk result to GitHub Code Scanning
              if: |
                  github.repository_owner == 'ptarmiganlabs' &&
                  matrix.os == 'ubuntu-latest'
              continue-on-error: true
              uses: github/codeql-action/upload-sarif@v3
              with:
                  sarif_file: snyk.sarif

            - name: Create binaries
              env:
                  DIST_FILE_NAME: butler
                  GITHUB_TOKEN: ${{ secrets.PAT }}
                  MACOS_CERTIFICATE: ${{ secrets.PROD_MACOS_CERTIFICATE_BASE64_CODESIGN }}
                  MACOS_CERTIFICATE_PWD: ${{ secrets.PROD_MACOS_CERTIFICATE_CODESIGN_PWD }}
                  MACOS_CERTIFICATE_NAME: ${{ secrets.PROD_MACOS_CERTIFICATE_CODESIGN_NAME }}
                  MACOS_CI_KEYCHAIN_PWD: ${{ secrets.PROD_MACOS_CI_KEYCHAIN_PWD }}
                  PROD_MACOS_NOTARIZATION_APPLE_ID: ${{ secrets.PROD_MACOS_NOTARIZATION_APPLE_ID }}
                  PROD_MACOS_NOTARIZATION_TEAM_ID: ${{ secrets.PROD_MACOS_NOTARIZATION_TEAM_ID }}
                  PROD_MACOS_NOTARIZATION_PWD: ${{ secrets.PROD_MACOS_NOTARIZATION_PWD }}
                  CODESIGN_WIN_THUMBPRINT: ${{ secrets.WIN_CODESIGN_THUMBPRINT}}
              run: |
                  pwd
                  ${{ matrix.build }}

            - name: Upload insider build artifacts to GitHub
              uses: actions/upload-artifact@v4
              with:
                  name: ${{ matrix.artifact_insider }}
                  path: ${{ matrix.artifact_insider }}

    deploy-windows-insider:
        needs: insiders-build
        runs-on: ${{ vars.BUTLER_INSIDER_DEPLOY_RUNNER || 'host2-win' }}
        if: success()
        env:
            BUTLER_INSIDER_SERVICE_NAME: ${{ vars.BUTLER_INSIDER_SERVICE_NAME || 'Butler insiders build' }}
            BUTLER_INSIDER_DEPLOY_PATH: ${{ vars.BUTLER_INSIDER_DEPLOY_PATH || 'C:\butler-insider' }}
            BUTLER_INSIDER_SERVICE_TIMEOUT: ${{ vars.BUTLER_INSIDER_SERVICE_TIMEOUT || '30' }}
            BUTLER_INSIDER_DOWNLOAD_PATH: ${{ vars.BUTLER_INSIDER_DOWNLOAD_PATH || './download' }}
        steps:
            - name: Download Windows insider build artifact
              uses: actions/download-artifact@v5
              with:
                  name: butler--win-x64--${{ github.sha }}.zip
                  path: ${{ env.BUTLER_INSIDER_DOWNLOAD_PATH }}

            - name: Deploy Windows insider build
              shell: powershell
              continue-on-error: true
              run: |
                  Write-Host "Starting deployment of Butler insiders build..."
                  Write-Host "Using configuration:"
                  Write-Host "  Runner: ${{ runner.name }}"
                  Write-Host "  Service Name: $env:BUTLER_INSIDER_SERVICE_NAME"
                  Write-Host "  Deploy Path: $env:BUTLER_INSIDER_DEPLOY_PATH"
                  Write-Host "  Service Timeout: $env:BUTLER_INSIDER_SERVICE_TIMEOUT seconds"
                  Write-Host "  Download Path: $env:BUTLER_INSIDER_DOWNLOAD_PATH"

                  # Define variables from environment
                  $serviceName = $env:BUTLER_INSIDER_SERVICE_NAME
                  $artifactPath = "$env:BUTLER_INSIDER_DOWNLOAD_PATH\butler--win-x64--${{ github.sha }}.zip"
                  $deployPath = $env:BUTLER_INSIDER_DEPLOY_PATH
                  $serviceTimeout = [System.Convert]::ToInt32($env:BUTLER_INSIDER_SERVICE_TIMEOUT)

                  try {
                      # Check if artifact exists
                      if (-not (Test-Path $artifactPath)) {
                          throw "Artifact not found at path: $artifactPath"
                      }
                      
                      Write-Host "Artifact found: $artifactPath"
                      
                      # Stop the service if it exists
                      Write-Host "Checking if service '$serviceName' exists..."
                      $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                      
                      if ($service) {
                          Write-Host "Service found. Current status: $($service.Status)"
                          
                          if ($service.Status -eq 'Running') {
                              Write-Host "Stopping service '$serviceName'..."
                              Stop-Service -Name $serviceName -Force -ErrorAction Stop
                              
                              # Wait for service to stop
                              $timer = 0
                              do {
                                  Start-Sleep -Seconds 1
                                  $timer++
                                  $service = Get-Service -Name $serviceName
                              } while ($service.Status -ne 'Stopped' -and $timer -lt $serviceTimeout)
                              
                              if ($service.Status -ne 'Stopped') {
                                  throw "Failed to stop service within $serviceTimeout seconds"
                              }
                              
                              Write-Host "Service stopped successfully"
                          } else {
                              Write-Host "Service is already stopped"
                          }
                      } else {
                          Write-Host "Service '$serviceName' not found. Will continue with deployment."
                      }
                      
                      # Create deployment directory if it doesn't exist
                      if (-not (Test-Path $deployPath)) {
                          Write-Host "Creating deployment directory: $deployPath"
                          New-Item -ItemType Directory -Path $deployPath -Force
                      }
                      
                      # Clear log files before deployment to ensure fresh logs
                      Write-Host "Clearing log files before deployment..."
                      $currentDate = Get-Date -Format "yyyy-MM-dd"
                      $serviceErrorLogPath = Join-Path $deployPath "service-error.log"
                      $dailyLogPath = Join-Path $deployPath "log\butler.$currentDate.log"
                      
                      Write-Host "Deploy path: $deployPath"
                      Write-Host "Current date: $currentDate"
                      Write-Host "Service error log path: $serviceErrorLogPath"
                      Write-Host "Daily log path: $dailyLogPath"
                      
                      # Check if log directory exists
                      $logDirectory = Join-Path $deployPath "log"
                      Write-Host "Log directory path: $logDirectory"
                      if (Test-Path $logDirectory) {
                          Write-Host "[OK] log directory exists"
                          Write-Host "Contents of log directory:"
                          Get-ChildItem -Path $logDirectory -Force | ForEach-Object { Write-Host "  $_" }
                      } else {
                          Write-Host "[WARN] log directory does not exist"
                      }
                      
                      if (Test-Path $serviceErrorLogPath) {
                          Write-Host "[OK] Found service-error.log at: $serviceErrorLogPath"
                          Write-Host "Clearing service-error.log..."
                          Clear-Content -Path $serviceErrorLogPath -Force
                          Write-Host "[OK] service-error.log cleared"
                      } else {
                          Write-Host "[WARN] service-error.log not found at: $serviceErrorLogPath"
                          Write-Host "Will be created if needed by the service"
                      }
                      
                      if (Test-Path $dailyLogPath) {
                          Write-Host "[OK] Found daily log file at: $dailyLogPath"
                          Write-Host "Clearing butler.$currentDate.log..."
                          Clear-Content -Path $dailyLogPath -Force
                          Write-Host "[OK] butler.$currentDate.log cleared"
                      } else {
                          Write-Host "[WARN] Daily log file not found at: $dailyLogPath"
                          Write-Host "Will be created if needed by the service"
                      }
                      
                      # Extract the zip file
                      Write-Host "Extracting artifact to $deployPath..."
                      Expand-Archive -Path $artifactPath -DestinationPath $deployPath -Force
                      
                      Write-Host "Deployment files extracted successfully"
                      
                      # List extracted contents
                      Write-Host "Extracted files:"
                      Get-ChildItem -Path $deployPath -Recurse | Format-Table Name, Length, LastWriteTime
                      
                      # Start the service if it exists
                      if ($service) {
                          Write-Host "Starting service '$serviceName'..."
                          Start-Service -Name $serviceName -ErrorAction Stop
                          
                          # Wait for service to start
                          $timer = 0
                          do {
                              Start-Sleep -Seconds 1
                              $timer++
                              $service = Get-Service -Name $serviceName
                          } while ($service.Status -ne 'Running' -and $timer -lt $serviceTimeout)
                          
                          if ($service.Status -eq 'Running') {
                              Write-Host "Service started successfully"
                          } else {
                              throw "Failed to start service within $serviceTimeout seconds. Service status: $($service.Status)"
                          }
                      } else {
                          Write-Host "Service not found. Binary deployed but service needs to be configured manually."
                      }
                      
                      Write-Host "[OK] Deployment completed successfully!"
                      
                  } catch {
                      Write-Host "[ERROR] Deployment failed: $($_.Exception.Message)" -ForegroundColor Red
                      Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
                      exit 1
                  }

            - name: Verify deployment
              shell: powershell
              continue-on-error: true
              run: |
                  Write-Host "Verifying deployment..."

                  $serviceName = $env:BUTLER_INSIDER_SERVICE_NAME
                  $deployPath = $env:BUTLER_INSIDER_DEPLOY_PATH

                  try {
                      # Check if deployment directory exists and has files
                      if (Test-Path $deployPath) {
                          Write-Host "Deployment directory exists: $deployPath"
                          $files = Get-ChildItem -Path $deployPath -Recurse
                          Write-Host "Number of files in deployment: $($files.Count)"
                          
                          # Check for the main executable
                          $executable = Get-ChildItem -Path $deployPath -Name "butler.exe" -Recurse
                          if ($executable) {
                              Write-Host "[OK] Main executable found: $executable"
                          } else {
                              Write-Host "[WARN] Main executable not found"
                          }
                      } else {
                          Write-Host "[ERROR] Deployment directory not found"
                      }
                      
                      # Check service status
                      $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                      if ($service) {
                          Write-Host "Service '$serviceName' status: $($service.Status)"
                          if ($service.Status -eq 'Running') {
                              Write-Host "[OK] Service is running"
                          } else {
                              Write-Host "[WARN] Service is not running"
                          }
                      } else {
                          Write-Host "[WARN] Service '$serviceName' not found"
                      }
                      
                  } catch {
                      Write-Host "[ERROR] Verification failed: $($_.Exception.Message)" -ForegroundColor Red
                  }

            - name: Check for errors in log files
              shell: powershell
              continue-on-error: true
              run: |
                  Write-Host "Checking for errors in log files after deployment..."

                  $deployPath = $env:BUTLER_INSIDER_DEPLOY_PATH
                  $currentDate = Get-Date -Format "yyyy-MM-dd"
                  $serviceErrorLogPath = Join-Path $deployPath "service-error.log"
                  $dailyLogPath = Join-Path $deployPath "log\butler.$currentDate.log"

                  Write-Host "Deploy path: $deployPath"
                  Write-Host "Current date: $currentDate"
                  Write-Host "Service error log path: $serviceErrorLogPath"
                  Write-Host "Daily log path: $dailyLogPath"

                  # Wait a moment for the service to start and potentially log entries
                  Write-Host "Waiting 30 seconds for service to initialize and create log entries..."
                  Start-Sleep -Seconds 30

                  $errorFound = $false

                  try {
                      # Check service-error.log
                      Write-Host "Checking for service-error.log at: $serviceErrorLogPath"
                      if (Test-Path $serviceErrorLogPath) {
                          Write-Host "[OK] Found service-error.log"
                          $serviceErrorContent = Get-Content -Path $serviceErrorLogPath -ErrorAction SilentlyContinue
                          if ($serviceErrorContent -and $serviceErrorContent.Count -gt 0) {
                              Write-Host "[ERROR] Errors found in service-error.log:" -ForegroundColor Red
                              $serviceErrorContent | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
                              $errorFound = $true
                          } else {
                              Write-Host "[OK] service-error.log is empty (no errors)"
                          }
                      } else {
                          Write-Host "[WARN] service-error.log does not exist at: $serviceErrorLogPath"
                      }
                      
                      # Check daily log file for error or fatal entries
                      Write-Host "Checking for daily log file at: $dailyLogPath"
                      if (Test-Path $dailyLogPath) {
                          Write-Host "[OK] Found daily log file"
                          $dailyLogContent = Get-Content -Path $dailyLogPath -ErrorAction SilentlyContinue
                          if ($dailyLogContent) {
                              # Match both formats: "error:" and "ERROR" (case-insensitive)
                              $errorEntries = $dailyLogContent | Where-Object { $_ -match "(?i)\b(error|fatal)[\s:]" }
                              if ($errorEntries -and $errorEntries.Count -gt 0) {
                                  Write-Host "[ERROR] Error/Fatal entries found in butler.$currentDate.log:" -ForegroundColor Red
                                  $errorEntries | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
                                  $errorFound = $true
                              } else {
                                  Write-Host "[OK] No error/fatal entries found in butler.$currentDate.log"
                              }
                              
                              Write-Host "Log file summary:"
                              Write-Host "  Total lines: $($dailyLogContent.Count)"
                              Write-Host "  info entries: $(($dailyLogContent | Where-Object { $_ -match "(?i)\binfo[\s:]" }).Count)"
                              Write-Host "  warn entries: $(($dailyLogContent | Where-Object { $_ -match "(?i)\bwarn[\s:]" }).Count)"
                              Write-Host "  error entries: $(($dailyLogContent | Where-Object { $_ -match "(?i)\berror[\s:]" }).Count)"
                              Write-Host "  fatal entries: $(($dailyLogContent | Where-Object { $_ -match "(?i)\bfatal[\s:]" }).Count)"
                          } else {
                              Write-Host "[OK] Daily log file is empty or has no content yet"
                          }
                      } else {
                          Write-Host "[WARN] Daily log file does not exist at: $dailyLogPath"
                      }
                      
                      if ($errorFound) {
                          Write-Host "[ERROR] Errors detected in log files - deployment may have issues" -ForegroundColor Red
                          # Don't fail the build, but make it visible
                          Write-Host "::warning::Errors found in log files after deployment"
                      } else {
                          Write-Host "[OK] No errors found in log files - deployment appears successful"
                      }
                      
                  } catch {
                      Write-Host "[ERROR] Failed to check log files: $($_.Exception.Message)" -ForegroundColor Red
                      Write-Host "::warning::Unable to check log files for errors"
                  }
